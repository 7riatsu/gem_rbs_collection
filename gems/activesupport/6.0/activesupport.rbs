module ActiveSupport
  module Callbacks
    module ClassMethods
      # Manual definition to make block optional
      def set_callback: (untyped name, *untyped filter_list) ?{ () -> untyped } -> untyped
                      | ...

      # Manual definition to make block optional
      def skip_callback: (untyped name, *untyped filter_list) ?{ () -> untyped } -> untyped
                       | ...
    end
  end

  module Configurable
    module ClassMethods
      # Manual definition to make block optional
      def config_accessor: (*untyped names, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer, ?instance_reader: bool instance_reader) ?{ () -> untyped } -> untyped
                         | ...
    end
  end

  class Deprecation
    class DeprecatedConstantProxy
      # Manual definition to make block optional
      def self.new: (*untyped args, **untyped kwargs) ?{ () -> untyped } -> untyped
                  | ...
    end
  end

  class HashWithIndifferentAccess[T, U] < Hash[T, U]
    # Manual definition to make block optional
    def fetch_values: (*untyped indices) ?{ () -> untyped } -> untyped
                    | ...

    # Manual definition to make block optional
    def merge: (untyped hash) ?{ () -> untyped } -> untyped
             | ...

    # Manual definition to make block optional
    def select: (*untyped args) ?{ () -> untyped } -> untyped
              | ...

    # Manual definition to make block optional
    def reject: (*untyped args) ?{ () -> untyped } -> untyped
              | ...

    # Manual definition to make block optional
    def transform_values: (*untyped args) ?{ () -> untyped } -> untyped
                        | ...

    # Manual definition to make block optional
    def transform_keys: (*untyped args) ?{ () -> untyped } -> untyped
                      | ...

    # Manual definition to make block optional
    def transform_keys!: () ?{ (untyped) -> untyped } -> untyped
                       | ...
  end

  module Testing
    module TimeHelpers
      # Manual definition to make block optional
      def travel: (untyped duration) ?{ () -> untyped } -> untyped
                | ...

      # Manual definition to make block optional
      def travel_to: (untyped date_or_time) ?{ () -> untyped } -> untyped
                   | ...

      # Manual definition to make block optional
      def freeze_time: () ?{ () -> untyped } -> untyped
                     | ...
    end
  end

  class TimeWithZone
    include DateAndTime::Calculations

    # class_eval
    def year: () -> Integer
    def mon: () -> Integer
    def month: () -> Integer
    def day: () -> Integer
    def mday: () -> Integer
    def wday: () -> Integer
    def yday: () -> Integer
    def hour: () -> Integer
    def min: () -> Integer
    def sec: () -> Integer
    def usec: () -> Integer
    def nsec: () -> Integer
    def to_date: () -> Date

    # method_missing
    def asctime: () -> String
    alias at_beginning_of_day beginning_of_day
    alias at_beginning_of_hour beginning_of_hour
    alias at_beginning_of_minute beginning_of_minute
    alias at_end_of_day end_of_day
    alias at_end_of_hour end_of_hour
    alias at_end_of_minute end_of_minute
    alias at_midday middle_of_day
    alias at_middle_of_day middle_of_day
    alias at_midnight beginning_of_day
    alias at_noon middle_of_day
    def beginning_of_day: () -> self
    def beginning_of_hour: () -> self
    def beginning_of_minute: () -> self
    def ceil: (?int ndigits) -> self
    def compare_with_coercion: (untyped other) -> (-1 | 0 | 1 | nil)
    def compare_without_coercion: (untyped other) -> (-1 | 0 | 1 | nil)
    def ctime: () -> String
    def end_of_day: () -> self
    def end_of_hour: () -> self
    def end_of_minute: () -> self
    def eql_with_coercion: (untyped other) -> bool
    def eql_without_coercion: (untyped other) -> bool
    def floor: (?int ndigits) -> self
    def friday?: () -> bool
    alias midday middle_of_day
    def middle_of_day: () -> self
    alias midnight beginning_of_day
    def minus_with_coercion: (Time | self arg0) -> Float
                           | (Numeric arg0) -> self
    def minus_with_duration: (Time | self arg0) -> Float
                           | (Numeric arg0) -> self
    def minus_without_coercion: (Time | self arg0) -> Float
                           | (Numeric arg0) -> self
    def minus_without_duration: (Time | self arg0) -> Float
                           | (Numeric arg0) -> self
    def monday?: () -> bool
    def next_day: () -> self
    def next_month: () -> self
    def next_year: () -> self
    alias noon middle_of_day
    def plus_without_duration: (Time | self arg0) -> Float
                             | (Numeric arg0) -> self
    def prev_day: () -> self
    def prev_month: () -> self
    def prev_year: () -> self
    def round: (?int ndigits) -> self
    def saturday?: () -> bool
    def seconds_since_midnight: () -> Float
    def seconds_until_end_of_day: () -> Integer
    def sec_fraction: () -> (Integer | Rational)
    def subsec: () -> (Integer | Rational)
    def sunday?: () -> bool
    def thursday?: () -> bool
    def to_default_s: () -> String
    def tuesday?: () -> bool
    def tv_nsec: () -> Integer
    def tv_usec: () -> Integer
    def wednesday?: () -> bool
  end
end

class Hash[unchecked out K, unchecked out V]
  # Manual definition to make block optional
  def deep_merge: (untyped other_hash) ?{ () -> untyped } -> untyped
                | ...

  # Manual definition to make block optional
  def deep_merge!: (untyped other_hash) ?{ () -> untyped } -> untyped
                 | ...

  def stringify_keys: () -> Hash[String, V]

  def stringify_keys!: () -> self

  def symbolize_keys: () -> Hash[Symbol, V]
  alias to_options symbolize_keys

  def symbolize_keys!: () -> self
  alias to_options! symbolize_keys!

  def deep_stringify_keys: () -> Hash[String, untyped]

  def deep_stringify_keys!: () -> self

  def deep_symbolize_keys: () -> Hash[Symbol, untyped]

  def deep_symbolize_keys!: () -> self
end

class Module
  # Manual definition to make block optional
  def mattr_reader: (*untyped syms, ?default: untyped? default, ?instance_accessor: bool instance_accessor, ?instance_reader: bool instance_reader) ?{ () -> untyped } -> untyped
                  | ...

  # Manual definition to make block optional
  def mattr_writer: (*untyped syms, ?default: untyped? default, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer) ?{ () -> untyped } -> untyped
                  | ...

  # Manual definition to make block optional
  def mattr_accessor: (*untyped syms, ?default: untyped? default, ?instance_accessor: bool instance_accessor, ?instance_writer: bool instance_writer, ?instance_reader: bool instance_reader) ?{ () -> untyped } -> untyped
                    | ...
end

class Integer
  prepend ActiveSupport::NumericWithFormat
end

class Float
  prepend ActiveSupport::NumericWithFormat
end

class BigDecimal
  prepend ActiveSupport::NumericWithFormat
end

module ActiveSupport
  module Tryable : BasicObject
    def try: [T] () { (self) -> T } -> T # When yield self
           | [T] () { () -> T } -> T # When instance_eval
           | (Object::name method_name, *untyped args) ?{ (*untyped) -> untyped } -> untyped

    def try!: [T] () { (self) -> T } -> T # When yield self
            | [T] () { () -> T } -> T # When instance_eval
            | (Object::name method_name, *untyped args) ?{ (*untyped) -> untyped } -> untyped
  end
end

class NilClass
    def try: () { (untyped) -> untyped } -> nil
           | () { () -> untyped } -> nil
           | (Object::name method_name, *untyped args) ?{ (*untyped) -> untyped } -> nil

    def try!: () { (untyped) -> untyped } -> nil
            | () { () -> untyped } -> nil
            | (Object::name method_name, *untyped args) ?{ (*untyped) -> untyped } -> nil

end

class Array[unchecked out Elem]
  # Manual definition to make block optional
  def in_groups: (untyped number, ?untyped? fill_with) ?{ (untyped) -> untyped } -> untyped
end

module ActiveSupport
  # Rescuable module adds support for easier exception handling.
  module Rescuable
    extend Concern

    module ClassMethods
      # Rescue exceptions raised in controller actions.
      #
      # <tt>rescue_from</tt> receives a series of exception classes or class
      # names, and a trailing <tt>:with</tt> option with the name of a method
      # or a Proc object to be called to handle them. Alternatively a block can
      # be given.
      #
      # Handlers that take one argument will be called with the exception, so
      # that the exception can be inspected when dealing with it.
      #
      # Handlers are inherited. They are searched from right to left, from
      # bottom to top, and up the hierarchy. The handler of the first class for
      # which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if
      # any.
      #
      #   class ApplicationController < ActionController::Base
      #     rescue_from User::NotAuthorized, with: :deny_access # self defined exception
      #     rescue_from ActiveRecord::RecordInvalid, with: :show_errors
      #
      #     rescue_from 'MyAppError::Base' do |exception|
      #       render xml: exception, status: 500
      #     end
      #
      #     private
      #       def deny_access
      #         ...
      #       end
      #
      #       def show_errors(exception)
      #         exception.record.new_record? ? ...
      #       end
      #   end
      #
      # Exceptions raised inside exception handlers are not propagated up.
      def rescue_from: (*Class) { (Exception) [self: instance] -> void } -> void
                     | (*Class, with: Symbol | ^(Exception) [self: instance] -> void) -> void

      # Matches an exception to a handler based on the exception class.
      #
      # If no handler matches the exception, check for a handler matching the
      # (optional) exception.cause. If no handler matches the exception or its
      # cause, this returns +nil+, so you can deal with unhandled exceptions.
      # Be sure to re-raise unhandled exceptions if this is what you expect.
      #
      #     begin
      #       (trim non-ascii characters)
      #     rescue => exception
      #       rescue_with_handler(exception) || raise
      #     end
      #
      # Returns the exception if it was handled and +nil+ if it was not.
      def rescue_with_handler: (untyped exception, ?visited_exceptions: untyped visited_exceptions, ?object: untyped object) -> untyped

      def handler_for_rescue: (untyped exception, ?object: untyped object) -> untyped

      private

      def find_rescue_handler: (untyped exception) -> untyped

      def constantize_rescue_handler_class: (untyped class_or_name) -> untyped
    end

    # Delegates to the class method, but uses the instance as the subject for
    # rescue_from handlers (method calls, instance_exec blocks).
    def rescue_with_handler: (untyped exception) -> untyped

    def handler_for_rescue: (untyped exception) -> untyped
  end
end
